算法 A*：
1. 生成一个只包含开始节点n0的搜索图G，把n0放在一个叫OPEN的列表上。
2. 生成一个列表CLOSED，它的初始值为空。
3. 如果OPEN为空，则失败退出。
4. 选择OPEN上的第一个节点，把它从OPEN中移入CLOSED，称该节点为n。
5. 如果n是目标节点，顺着G中，从n到n0的指针找到一条路径，获得解决方案，成功退出（该指针定义了一个搜索树，在第7步建立）。
6. 扩展节点n，生成其后继节点集M，在G中，n的祖先不能在M中。在G中安置M的成员，使它们成为n的后继。
7. 从M的每一个不在G中的成员建立一个指向n的指针（例如，既不在OPEN中，也不在CLOSED中）。把M的这些成员加到OPEN中。对的每一个已在OPEN 中或CLOSED中的成员m，如果到目前为止找到的到达m的最好路径通过n，就把它的指针指向n。对已在CLOSE中的M的每一个成员，重定向它在G中的每一个后继，以使它们顺着到目前为止发现的最好路径指向它们的祖先。
8. 按递增值，重排OPEN（相同最小值可根据搜索树中的最深节点来解决）。
9. 返回第3步。
